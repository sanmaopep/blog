# DP经典问题

## 背包问题

### 01背包问题



#### 简单变形：硬币数最少



## 常见类型

### 最大子串和

> **问题描述：**
>
> 对于一个包含负值的数字串array[1...n]，要找到他的一个子串array[i...j]（0<=i<=j<=n），使得在array的所有子串中，array[i...j]的和最大。

这是一道非常常见的DP题，虽然很水，但是我们还是用严谨的思维来说明一下这个问题。

假设子串array[i...j]拥有最大和，则该子串满足以下性质：

1. **该区间的第一个元素和最后一个元素一定大于等于0，即array[i] 和 array[j] 一定大于等于0。** 

   该命题可以用反证法证明，证明过程如下：

   **证明：** 假设第一个元素为负数，则存在区间array[i+1...j]，该区间的子串和大于array[i...j]。

   这与子串array[i...j]拥有最大和矛盾，故第一个元素一定大于等于0。

   类似地，可以证明最后一个元素一定大于等于0。

2. **如果区间内存在负数（假设下标为k），子串和array[i...k]一定大于等于0。**

   利用反证法证明，证明如下：

   **证明：**假设字串和array[i...k]小于0，则存在子串和array[k+1...j] = array[i...j] - array[i...k]，其结果大于array[i...j]。

   这与命题矛盾，故array[i...k]大于0。

3. **如果i不为第一个元素，则array[i-1]一定小于0。如果j不为最后一个元素，则array[j+1]一定小于0。**

   这个命题依旧可以用反证法来证明，具体过程留给读者作为练习。

给出这两个性质，我们可以轻松地给出最大子串和地线性时间算法：



### LIS 最大上升子序列



### E[j]=opt{D+w(i,j)}



### E[i,j]=opt{D[i-1,j]+xi,D[i,j-1]+yj,D[i-1,j-1]+zij} (最长公共子序列)



常常用画二维表格的方法来表现。



适合模型：两个串进行某种PY的时候。

### C[i,j]=w[i,j]+opt{C[i,k-1]+C[k,j]}.(最优二分检索树问题)





### C[i,j]=opt{C[i,k-1]+C[k,j]+w(i,j,k)}(最优矩阵连乘)



